#!/usr/bin/env python3

# SPDX-FileCopyrightText: The RamenDR authors
# SPDX-License-Identifier: Apache-2.0

import base64
import concurrent.futures
import json
import os
import sys
import time

from contextlib import closing

import yaml

import drenv
from drenv import ceph
from drenv import commands
from drenv import kubectl

POOL_NAMES = ["replicapool", "replicapool-2"]


def log_blocklist(cluster):
    blocklist = ceph.list_osd_blocklist(cluster)
    if blocklist:
        info = {f"Cluster '{cluster}' ceph osd blocklist": blocklist}
        print(yaml.dump(info, sort_keys=False))


def fetch_secret_info(cluster, pool):
    info = {}

    print(f"Getting mirroring info site name for cluster '{cluster}' and cephblockpool {pool}")
    info["name"] = drenv.wait_for(
        f"cephblockpools.ceph.rook.io/{pool}",
        output="jsonpath={.status.mirroringInfo.site_name}",
        namespace="rook-ceph",
        profile=cluster,
    )

    print(f"Getting rbd mirror boostrap peer secret name for cluster '{cluster}'")
    secret_name = kubectl.get(
        "cephblockpools.ceph.rook.io",
        pool,
        "--output=jsonpath={.status.info.rbdMirrorBootstrapPeerSecretName}",
        "--namespace=rook-ceph",
        context=cluster,
    )

    print(f"Getting secret {secret_name} token for cluster '{cluster}'")
    info["token"] = kubectl.get(
        "secret",
        secret_name,
        "--output=jsonpath={.data.token}",
        "--namespace=rook-ceph",
        context=cluster,
    )

    # Must be encoded as base64 in secret .data section.
    info["pool"] = base64.b64encode(pool.encode()).decode()

    return info


def enable_rbd_mirror_debug_logs(cluster):
    print(f"Enable rbd-mirror debug logs in cluster '{cluster}'")
    for who in "client.rbd-mirror.a", "client.rbd-mirror-peer":
        ceph.set_config(cluster, who, "debug_ms", "1")
        ceph.set_config(cluster, who, "debug_rbd", "15")
        ceph.set_config(cluster, who, "debug_rbd_mirror", "30")
        ceph.set_config(cluster, who, "log_file", "/var/log/ceph/$cluster-$name.log")
    ceph.set_config(cluster, "mgr", "mgr/rbd_support/log_level", "debug")


def disable_rbd_mirror_debug_logs(cluster):
    print(f"Disable rbd-mirror debug logs in cluster '{cluster}'")
    for who in "client.rbd-mirror.a", "client.rbd-mirror-peer":
        ceph.rm_config(cluster, who, "debug_ms")
        ceph.rm_config(cluster, who, "debug_rbd")
        ceph.rm_config(cluster, who, "debug_rbd_mirror")
        ceph.rm_config(cluster, who, "log_file")
    ceph.rm_config(cluster, "mgr", "mgr/rbd_support/log_level")


def configure_rbd_mirroring(cluster, pool, peer_info):
    print(f"Applying rbd mirror secret in cluster '{cluster}' for cephblockpool {pool}")

    template = drenv.template("start-data/rbd-mirror-secret.yaml")
    yaml = template.substitute(peer_info)
    kubectl.apply(
        "--filename=-",
        "--namespace=rook-ceph",
        input=yaml,
        context=cluster,
    )

    print(f"Configure peers for cluster '{cluster}'")
    patch = {
        "spec": {"mirroring": {"peers": {"secretNames": [peer_info["name"]]}}}
    }
    kubectl.patch(
        "cephblockpool",
        pool,
        "--type=merge",
        f"--patch={json.dumps(patch)}",
        "--namespace=rook-ceph",
        context=cluster,
    )

    vrc_name = "vrc-sample"
    vgrc_name = "vgrc-sample"
    if pool != 'replicapool':
        num = pool.split("-")[1]
        vrc_name = f"{vrc_name}-{num}"
        vgrc_name = f"{vgrc_name}-{num}"

    print("Creating VolumeReplicationClass")
    template = drenv.template("start-data/vrc-sample.yaml")
    yaml = template.substitute(name=vrc_name, cluster=cluster, pool=pool)
    kubectl.apply("--filename=-", input=yaml, context=cluster)

    print("Creating VolumeGroupReplicationClass")
    template = drenv.template("start-data/vgrc-sample.yaml")
    yaml = template.substitute(name=vgrc_name, cluster=cluster, pool=pool)
    kubectl.apply("--filename=-", input=yaml, context=cluster)

    print(f"Apply rbd mirror to cluster '{cluster}'")
    kubectl.apply("--kustomize=start-data", context=cluster)


def wait_until_rbd_mirror_is_ready(cluster):
    print(f"Waiting until rbd mirror is ready in cluster '{cluster}'")
    drenv.wait_for(
        "cephrbdmirror/my-rbd-mirror",
        output="jsonpath={.status.phase}",
        namespace="rook-ceph",
        profile=cluster,
    )
    kubectl.wait(
        "cephrbdmirror/my-rbd-mirror",
        "--for=jsonpath={.status.phase}=Ready",
        "--namespace=rook-ceph",
        "--timeout=300s",
        context=cluster,
    )
    status = kubectl.get(
        "cephrbdmirror/my-rbd-mirror",
        "--output=jsonpath={.status}",
        "--namespace=rook-ceph",
        context=cluster,
    )
    info = {f"Cluster '{cluster}' rbd mirror status": json.loads(status)}
    print(yaml.dump(info, sort_keys=False))


def wait_until_pool_mirroring_is_healthy(cluster, pool, attempts=3):
    # We have random timeouts when rbd-mirror fail to connect to the peer.
    # When this happens we can recover by restarting the rbd-mirror daemon.

    for i in range(1, attempts + 1):
        print(f"Waiting for mirroring health in cluster '{cluster}' ({i}/{attempts})")
        try:
            watch_pool_mirroring_status(cluster, pool)
        except commands.Timeout:
            if i == attempts:
                raise

            print(f"Timeout waiting for mirroring health in cluster '{cluster}'")
            restart_rbd_mirror_daemon(cluster)
        else:
            break

    status = kubectl.get(
        "cephblockpools.ceph.rook.io",
        pool,
        "--output=jsonpath={.status}",
        "--namespace=rook-ceph",
        context=cluster,
    )
    info = {f"Cluster '{cluster}' cephblockpool {pool} status": json.loads(status)}
    print(yaml.dump(info, sort_keys=False))


def watch_pool_mirroring_status(cluster, pool, timeout=180):
    """
    Watch pool .status.mirroringStatus.summary until mirroring is healthy or
    the timeout expires.
    """
    start = time.monotonic()
    deadline = start + timeout

    while True:
        remaining = deadline - time.monotonic()
        watcher = kubectl.watch(
            f"cephblockpool/{pool}",
            jsonpath="{.status.mirroringStatus.summary}",
            namespace="rook-ceph",
            timeout=remaining,
            context=cluster,
        )
        with closing(watcher):
            for line in watcher:
                summary = json.loads(line)
                print(f"Cluster '{cluster}' mirroring status': {summary}")

                if mirroring_is_healthy(summary):
                    elapsed = time.monotonic() - start
                    print(
                        f"Cluster '{cluster}' mirroring healthy in {elapsed:.2f} seconds"
                    )
                    return


def mirroring_is_healthy(summary):
    return (
        summary["daemon_health"] == "OK"
        and summary["health"] == "OK"
        and summary["image_health"] == "OK"
    )


def restart_rbd_mirror_daemon(cluster):
    # TODO: Get the name from the cluster.
    deploy = "deploy/rook-ceph-rbd-mirror-a"

    print(f"Restarting {deploy} in cluster '{cluster}'")
    kubectl.rollout("restart", deploy, "--namespace=rook-ceph", context=cluster)

    print(f"Waiting until {deploy} is rolled out in cluster '{cluster}'")
    kubectl.rollout(
        "status",
        deploy,
        "--namespace=rook-ceph",
        "--timeout=120s",
        context=cluster,
    )


def test(cluster1, cluster2, pool):
    cluster1_info = fetch_secret_info(cluster1, pool)
    cluster2_info = fetch_secret_info(cluster2, pool)

    print(f"Setting up mirroring from '{cluster2}' to '{cluster1}'")
    configure_rbd_mirroring(cluster1, pool, cluster2_info)

    print(f"Setting up mirroring from '{cluster1}' to '{cluster2}'")
    configure_rbd_mirroring(cluster2, pool, cluster1_info)

    wait_until_rbd_mirror_is_ready(cluster1)
    wait_until_rbd_mirror_is_ready(cluster2)

    log_blocklist(cluster1)
    log_blocklist(cluster2)

    wait_until_pool_mirroring_is_healthy(cluster1, pool)
    wait_until_pool_mirroring_is_healthy(cluster2, pool)


if len(sys.argv) != 3:
    print(f"Usage: {sys.argv[0]} cluster1 cluster2")
    sys.exit(1)

os.chdir(os.path.dirname(__file__))
cluster1 = sys.argv[1]
cluster2 = sys.argv[2]

# Run with RBD_MIRROR_DEBUG=1 to enable debug logs.
if os.environ.get("RBD_MIRROR_DEBUG") == "1":
    enable_rbd_mirror_debug_logs(cluster1)
    enable_rbd_mirror_debug_logs(cluster2)
else:
    disable_rbd_mirror_debug_logs(cluster1)
    disable_rbd_mirror_debug_logs(cluster2)

with concurrent.futures.ThreadPoolExecutor() as e:
    tests = []
    for pool in POOL_NAMES:
        tests.append(e.submit(test, cluster1, cluster2, pool))

    for t in concurrent.futures.as_completed(tests):
        t.result()

print("Mirroring was setup successfully")
