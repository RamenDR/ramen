#!/usr/bin/env python3

# SPDX-FileCopyrightText: The RamenDR authors
# SPDX-License-Identifier: Apache-2.0

import json
import os
import sys
import time
import uuid

from drenv import kubectl

POOL_NAME = "replicapool"
PVC_NAME = "rbd-pvc"
VGR_NAME = "vgr-1m"


def to_csi_vol_group(s: str, prefix: str = "csi-vol-group") -> str:
    parts = s.rsplit("-", 5)  # split at the 5 rightmost dashes
    if len(parts) < 6:
        raise RuntimeError(f"Expected a trailing UUID, got: {s!r}")

    candidate = "-".join(parts[1:6])  # the 5 UUID chunks
    try:
        u = str(uuid.UUID(candidate))  # validate & normalize
    except ValueError as e:
        raise RuntimeError(f"Trailing token is not a valid UUID: {candidate!r}") from e

    return f"{prefix}-{u}"


def rbd(*args, cluster=None):
    """
    Run a rbd command using the ceph toolbox on the specified cluster and
    return the output.
    """
    return kubectl.exec(
        "deploy/rook-ceph-tools",
        "--namespace=rook-ceph",
        "--",
        "rbd",
        *args,
        f"--pool={POOL_NAME}",
        context=cluster,
    )


def rbd_mirror_image_status(cluster, image):
    out = rbd(
        "mirror",
        "group",
        "status",
        image,
        "--format=json",
        cluster=cluster,
    )
    status = json.loads(out)

    # Exapand metrics json embdeded in the peer description.
    for peer in status["peer_sites"]:
        desc = peer.get("description", "")
        if ", " in desc:
            state, metrics = desc.split(", ", 1)
            peer["description"] = {
                "state": state,
                "metrics": json.loads(metrics),
            }

    return status


def test_volume_replication(primary, secondary):
    print(f"Deploying pvc {PVC_NAME} and vgr {VGR_NAME} in cluster '{primary}'")
    kubectl.apply("--kustomize=test-data", context=primary)

    print(f"Waiting until pvc {PVC_NAME} is bound in cluster '{primary}'")
    kubectl.wait(
        f"pvc/{PVC_NAME}",
        "--for=jsonpath={.status.phase}=Bound",
        "--namespace=rook-ceph",
        "--timeout=300s",
        context=primary,
    )

    print(f"Waiting until vgr {VGR_NAME} is completed in cluster '{primary}'")
    kubectl.wait(
        f"volumegroupreplication/{VGR_NAME}",
        "--for=condition=Completed",
        "--namespace=rook-ceph",
        "--timeout=300s",
        context=primary,
    )

    print(f"Waiting until vgr {VGR_NAME} state is primary in cluster '{primary}'")
    kubectl.wait(
        f"volumegroupreplication/{VGR_NAME}",
        "--for=jsonpath={.status.state}=Primary",
        "--namespace=rook-ceph",
        "--timeout=300s",
        context=primary,
    )

    print(f"Looking up pvc {PVC_NAME} pv name in cluster '{primary}'")
    vgrcontent_name = kubectl.get(
        f"volumegroupreplication/{VGR_NAME}",
        "--output=jsonpath={.spec.volumeGroupReplicationContentName}",
        "--namespace=rook-ceph",
        context=primary,
    )

    print(
        f"Looking up rbd image for vrgcontent {vgrcontent_name} in cluster '{primary}'"
    )
    rbd_handle = kubectl.get(
        f"volumegroupreplicationcontent/{vgrcontent_name}",
        "--output=jsonpath={.spec.volumeGroupReplicationHandle}",
        "--namespace=rook-ceph",
        context=primary,
    )

    rbd_image = to_csi_vol_group(rbd_handle)

    print(f"rbd image {rbd_image} info in cluster '{primary}'")
    out = rbd("group", "info", rbd_image, cluster=primary)
    print(out)

    print(f"Waiting until rbd image {rbd_image} is created in cluster '{secondary}'")
    for i in range(60):
        time.sleep(1)
        out = rbd("group", "list", cluster=primary)
        if rbd_image in out:
            out = rbd("group", "info", rbd_image, cluster=primary)
            print(out)
            break
    else:
        raise RuntimeError(f"Timeout waiting for image {rbd_image}")

    print(f"vgr {VGR_NAME} info on primary cluster '{primary}'")
    kubectl.get(
        f"volumegroupreplication/{VGR_NAME}",
        "--output=yaml",
        "--namespace=rook-ceph",
        context=primary,
    )

    print(f"rbd mirror image status in cluster '{primary}'")
    image_status = rbd_mirror_image_status(primary, rbd_image)
    print(json.dumps(image_status, indent=2))

    print(f"Deleting pvc {PVC_NAME} and vgr {VGR_NAME} in primary cluster '{primary}'")
    kubectl.delete("--kustomize=test-data", context=primary)

    print(f"Replication from cluster '{primary}' to cluster '{secondary}' succeeded")


if len(sys.argv) != 3:
    print(f"Usage: {sys.argv[0]} cluster1 cluster2")
    sys.exit(1)

os.chdir(os.path.dirname(__file__))
cluster1 = sys.argv[1]
cluster2 = sys.argv[2]

test_volume_replication(cluster1, cluster2)
test_volume_replication(cluster2, cluster1)
