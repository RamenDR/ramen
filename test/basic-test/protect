#!/usr/bin/env python3

# SPDX-FileCopyrightText: The RamenDR authors
# SPDX-License-Identifier: Apache-2.0

import json

import drenv
from drenv import kubectl
from drenv import test

test.start("protect", __file__)
args = test.parse_args()
config = test.config

test.info("Enabling DR for application '%s'", config["namespace"])

test.info("Setting '%s' placement scheduler to ramen", config["namespace"])
patch = {"spec": {"schedulerName": "ramen"}}
kubectl.patch(
    f"placementrule/{config['placement']}",
    "--patch",
    json.dumps(patch),
    "--type=merge",
    f"--namespace={config['namespace']}",
    context=test.env["hub"],
    log=test.debug,
)

cluster = kubectl.get(
    f"placementrule/{config['placement']}",
    f"--namespace={config['namespace']}",
    "--output=jsonpath={.status.decisions[0].clusterName}",
    context=test.env["hub"],
)

out = kubectl.get(
    f"pvc/{config['pvc']}",
    f"--namespace={config['namespace']}",
    "--output=json",
    context=cluster,
)
pvc_before = json.loads(out)

test.info("Deploying '%s' drpc", config["namespace"])
with drenv.kustomization(
    "dr/kustomization.yaml",
    namespace=config["namespace"],
    repo=config["repo"],
    branch=config["branch"],
    cluster=cluster,
) as sub:
    kubectl.apply(f"--kustomize={sub}", context=test.env["hub"], log=test.debug)

test.info("Waiting until '%s' drpc reports phase", config["namespace"])
drenv.wait_for(
    f"drpc/{config['drpc']}",
    output="jsonpath={.status.phase}",
    namespace=config["namespace"],
    timeout=60,
    profile=test.env["hub"],
    log=test.debug,
)

test.info("Waiting until '%s' drpc is deployed", config["namespace"])
kubectl.wait(
    f"drpc/{config['drpc']}",
    "--for=jsonpath={.status.phase}=Deployed",
    f"--namespace={config['namespace']}",
    "--timeout=60s",
    context=test.env["hub"],
    log=test.debug,
)

out = kubectl.get(
    f"pvc/{config['pvc']}",
    f"--namespace={config['namespace']}",
    "--output=json",
    context=cluster,
)
pvc_after = json.loads(out)

# Verify that the PVC and PV were not modified by protecting the app.
# (not sure that this is the best way).

if pvc_after["metadata"]["uid"] != pvc_before["metadata"]["uid"]:
    raise RuntimeError(f"PVC uid changed: before={pvc_after} after={pvc_before}")

if pvc_after["spec"]["volumeName"] != pvc_before["spec"]["volumeName"]:
    raise RuntimeError(f"PVC volume changed: before={pvc_after} after={pvc_before}")

# But the PV reclaim policy must change to "Retain".
# XXX fail randomly - probably need to wait for some condition before checking the pv.

out = kubectl.get(
    "pv",
    pvc_after["spec"]["volumeName"],
    "--output=json",
    context=cluster,
)
pv = json.loads(out)
if pv["spec"]["persistentVolumeReclaimPolicy"] != "Retain":
    raise RuntimeError(f"Unexpected PV reclaim policy: {pv}")

test.info("Waiting until '%s' application is replicated", config["namespace"])
drenv.wait_for(
    f"drpc/{config['drpc']}",
    output="jsonpath={.status.lastGroupSyncTime}",
    namespace=config["namespace"],
    timeout=300,
    profile=test.env["hub"],
    log=test.debug,
)

test.info("Application '%s' was protected successfully", config["namespace"])
